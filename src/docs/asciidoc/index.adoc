= Apache Isis - Closing the Architecture/Code&nbsp;Gap

Dan Haywood & Eoin Woods


:backend: revealjs
:revealjs_progress: true


ifndef::imagesdir[:imagesdir: images]
ifndef::sourcedir[:sourcedir: ../java]



[NOTE.speaker]
====
Original abstract:

* A problem all software projects encounter is making sure that code reflects the desired architectural principles/constraints. Many approaches have been tested, but the practical unification of architecture and code still eludes us.

* Apache Isis takes a different approach, forcibly separating architectural constructs from domain model, combining the two at runtime. It promises to free the developer from writing “boilerplate” and focus on the domain model instead.

* In this talk we’re going to explore these architectural issues and demonstrate how the framework addresses these.
====




== About Us

* *Eoin Woods* is CTO at Endava, a European IT services company.  He is also the author of “Software Systems Architecture”

* *Dan Haywood* is an independent consultant & developer specializing in domain driven design.  He is an Apache member and PMC chair for Apache Isis

* We met and worked together in the 90s at Sybase, and have (as friends) tracked each other's respective careers ever since.


[NOTE.speaker]
--
TODO: let's sprinkle some of the trade-offs throughout, which allows Eoin to put the thing into a larger context
--




[.eoin]
== The Problem with Successful Systems

Long lived applications typically suffer from a number of architectural problems.
[%step]

* the architectural style in use slowly erodes until it is hard to discern
* new features are needed and it is not clear how they relate to the existing architecture
* programming patterns, crisply implemented initially, start to soften and become unclear
* overall coherency starts to weaken because the implemented architecture evolves informally in a piecemeal fashion

[%step]
_Change becomes difficult (partly) because implementation and architecture drift apart.  This is inevitable because they are different artefact groups._


[.eoin]
== Specific Problems

[%step]

* Business logic drifts into adjacent layers
* Domain model becomes unwieldy with duplication and "tactical" changes creeping in
* Key aspects of the architecture are forgotten or misinterpreted
* Rushed changes introduce parts of the system that don't fit the architecture at all (the inevitable "special case" modules)
* New parts of the system are difficult to test, deploy or support
* Utility modules mysteriously grow in size and scope (can be called from anywhere!)
* Rationale for key decisions is forgotten leading to poor evolution
* New developers are unaware of the local development idioms so break them


[.dan]
== Apache Isis (and naked objects)

* The Apache Isis framework is an implementation of the naked objects pattern
* Named & developed by Richard&nbsp;Pawson and Rob&nbsp;Matthews
** further details in Richard's "Naked&nbsp;Objects" PhD thesis
** external examiner was Trygve Reenskaug


[NOTE.speaker]
--
TODO: quote Trvyge: what MVC was meant to be, "we never got around to it"
--




[.dan]
[%notitle]
=== a system...


[.thumb]
image::what-is-nakedobjects/110.PNG[width=960px]


[.dan]
[%notitle]
=== with layers


[.thumb]
image::what-is-nakedobjects/120.PNG[width=960px]



[.dan]
[%notitle]
=== generic presentation & persistence

image::what-is-nakedobjects/130.PNG[width=960px]


[.dan]
[%notitle]
=== so we can ignore

image::what-is-nakedobjects/140.PNG[width=960px]



[.dan]
[%notitle]
=== hexagonal architecture

image::what-is-nakedobjects/150.PNG[width=960px]




[.dan]
[%notitle]
=== with viewers and object stores

image::what-is-nakedobjects/160.PNG[width=960px]





[.dan]
=== A metaphor: the incredible machine


[.thumb]
image::what-is-nakedobjects/incredible-machine.png[width=650px]




[.eoin]
== Generic UI/UX


[%step]

Genericity in a UI not a goal, but investing in automatic UI generation has a number of advantages.

* A high quality UI is expensive to develop and difficult to get right
* Skills in UI and UX work are relatively rare in most organisations
* Difficult to create a UI which is consistent across a large application (let alone across applications)
* Generated UIs "upgrade" the whole UI at once (e.g. improved date picker)
* UI fashions change so avoiding lots of custom development in the UI allows easier replacement
* Having the framework generate the UI prevents accidental domain model / logic / UI coupling.

Using a generic UI allows reuse of skills, guarantees base standard of UI and provides easier evolution - *provided* that the investment in the generic UI framework is made!

Tradeoff is innability to (easily) support special cases or experimentation.


[NOTE.speaker]
====
some discussion on why a generic UI might be useful/beneficial.

Things eoin mentioned last Friday included: "Why's this useful?  Because we can get a meaningful user-interface "for free".  Valuable because UX/UI is expensive to develop, is difficult to get right, difficult to keep consistent, is a fashion item so the most important bit to ensure that there are no dependencies upon...

also worth mentioning: provides is consistency throughout, with new features automatically available everywhere (eg hint support, icons via regex, calendars/maps)

eoin: can we see an example of such a generic UI?
====



[.dan]
=== Generic UIs are "good enough" for many applications

* ... though it has, admittedly, been a journey to get them to that level!



[NOTE.speaker]
====
dan: the irony of writing a naked objects framework if one is more interested in the domain than in the UI...
====


[.dan]
[%notitle]
=== 2005
image::history/2005-dnd.png[width=960px]

[.dan]
[%notitle]
=== 2006
image::history/2006-dsfa.png[width=960px]

[.dan]
[%notitle]
=== 2007
image::history/2007-rcp.png[width=960px]

[.dan]
[%notitle]
=== 2009
image::history/2009-scimpi.png[width=960px]

[.dan]
[%notitle]
=== 2012 wicket
image::history/2012-wicket.png[width=960px]

[.dan]
[%notitle]
=== 2013
image::history/2013-TransportDemand.png[width=960px]

[.dan]
[%notitle]
=== 2014
image::history/2014-estatio.png[width=960px]

[.dan]
[%notitle]
=== 2015
image::history/2015-estatio.png[width=960px]

[.dan]
[%notitle]
=== 2016
image::history/2016-todoapp.png[width=960px]



[.dan]
== An example: Estatio

* *_Estatio_* is an invoicing application for tenants within a shopping centre
* Developed for Eurocommercial Properties, currently deployed to Italy and France
* The code also happens to be open source (on github)


[.dan]
[%notitle]
=== ... demo ...


link:images/rad/estatio-resetDates.mp4[demo: UI derived from domain model]




[.eoin]
== Customizing the UI

As we already discussed, a generic UI can have a lot of advantages when it comes to development efficiency, UX consistency and future proofing.

What are the trade offs?

[%step]

* How much control can an individual application have on its UI?
* Can layout, look-and-feel, flow, colour be changed easily?
* What if an application needs a new widget type entirely?

[NOTE.speaker]
====
eoin: trade-offs, to what extent can this UI be customized?

From Eoin: when I came to it, I wasn't quite sure what I was meant to say here, so I've asked some motivating questions around UI customisation.  If any are unhelpful we can field or remove them!

Suggest hold back the question on alternative UIs to next section
====


[.dan]
=== Customizing the UI


* Use annotations, provide UI hints
** eg `@Action` vs `@ActionLayout`
* Optional `.layout.xml`
** basically a DSL, modelled on Bootstrap
* CSS
** classes and Ids generated from the metamodel
* Plugins to render maps, calendars etc.




[.dan]
[%notitle]
=== ... demo ...

link:images/rad/estatio-layout.mp4[demo: customizing the UI using `.layout.xml`]





[.eoin]
== Alternative UIs

One of the advantages of a framework provided UI is its support for evolution, but how does this work?

[%step]

* Can you replace the UI technology in use without affecting core code?
* Can you provide more than one UI simultaneously?
* What does Isis assume about the UI technology it uses?


[NOTE.speaker]
====
eoin: and what about completely different UIs?
====




[.dan]
=== GES Consultor

image::alternatives/gesconsultor.png[width=960px]



[NOTE.speaker]
====
dan: take about ~3 months to write a new custom UI, eg Vaadin, Polymer
====



[.dan]
=== User Archetypes

image::alternatives/210.png[width=960px]




[.dan]
[%notitle]
=== REST (Swagger)


image::alternatives/swagger.png[width=960px]



[.dan]
[%notitle]
=== Example of a custom UI: contactapp

link:images/alternatives/contactapp-1.mp4[example of a custom UI: contactapp]




[.dan]
=== Testing "UI"

* the framework provides a small testing framework that emulates the UI

* link:images/alternatives/contactapp-2.mp4[example functionality within contactapp]




[.dan]
[%notitle]
=== Testing "UI"

[source,java]
----
@Test
public void name_already_in_use_by_contact() throws Exception {
  // given
  final String existingName =
                        fs.getContacts().get(1).getName();
  // expect
  thrown.expect(InvalidException.class);
  thrown.expectMessage("Reason: " +
        "This name is already in use by another contact");
  // when
  wrap(this.contact).edit(existingName, null, null, null);
}
----




[.eoin]
== Architectural Constraints

One of the reasons that implementation and architecture drift is that its hard to remember the architectural constraints ("guide rails") when you're in the code.

[%step]

* Constraints are there to limit some amount of implementation freedom
* This allows focus on what is really important and prevents "drift"
* In most systems it's hard to know how the architectural constraint is realised
* Frameworks like Isis try to embody the architecture (and its constraints) in the framework

Try to make the "right" thing the "easy" thing


[.dan]
[%notitle]
=== hexagonal architecture

image::what-is-nakedobjects/150.PNG[width=960px]






[.dan]
[%notitle]
=== firewalls

image::architecture-constraints/180.png[width=960px]





[.dan]
=== Metamodel validators

* Used by framework itself
** eg to enforce naming conventions
* Extensible for other application-specific use cases
* Metamodel itself is extensible
** Extension object pattern




[.eoin]
== Coupling to the Framework?

Most frameworks are a "lifestyle choice" needing high commitment to them.  You have to be coupled to something (even if only a language).  What is being coupled to Isis like?

[%step]

* What constraints does Isis place on the *domain model* code?
* What degree of dependence does domain code *need* to have on Isis?
* What degree of dependence does domain code *generally have* on Isis?
* Could Isis domain models realistically be used elsewhere?
* Can Isis domain models be shared with other uses?
* How practical is it to replace 3rd party components used by Isis?  (e.g. persistence layer ORM)


[NOTE.speaker]
====
.... the idea of this section (if there's time) is to address the point that when you use a framework there's always some sort of "coupling"; either technical, or (more interestingly) in terms of having the same set of values/beliefs as the framework's authors

... latter provides an opportunity to do a demo on feedback loops/explorations
====




[.dan]
=== Decoupling from the framework

[%step]

* Apache Isis is a framework, not a library
** Domain objects have a compiled-time coupling to the "applib" (annotations), but that's about all
* Could deploy an Apache Isis app on Spring, for example
** ... or any other framework providing runtime support for dependency injection and an ORM




[.dan]
=== Beliefs/prejudices

* Too much emphasis on technical concerns
** exhibit A: microservices
* Conversely, not enough on the domain
* Feedback loop is the most important thing
** a generic UI keeps the discussion centred on the domain, not the UI




[.dan]
[%notitle]
=== An example exploration


link:images/feedback-loop/colab2.mp4[example of feedback loops: colab2-exploration]



[NOTE.speaker]
====
dan: fixture scripts; choosing titles and icons ...
====





[.eoin]
== Maintainable Monoliths

Current fashion is towards "microservices" (often without much thought as to trade offs).  However monoliths are perfectly maintainable if well built and evolved.

[%step]

* Genuine modularity and dependency management is key
* Understanding many types of coupling (message, data, control, global data, pathological)
* Ensure high cohesion in modules to avoid "buckets of code"
* Need to achieve measurement and visibility

This is all easier to enforce when code is physically separate (hence microservices) but can be done in a monolith perfectly well.

How does Isis do it?

[NOTE.speaker]
====
eoin: considering larger architectural concerns... modularity
====



[.dan]
[%notitle]
=== monoliths are maintainable if...


image::modules/310.PNG[width=960px]


[.dan]
[%notitle]
=== ... decomposed into modules

image::modules/320.png[width=960px]



[.dan]
=== Modularity support in Apache Isis

* **__Mixin__**s move functionality out of domain objects
** composite UI creates a coherent whole for the end-user

* **__Domain event__**s coordinate/veto interactions between different modules within the system

* **__URN__**s, enabling polymorphic associations
** "table of two halves" pattern


[.dan]
=== Mixins

image::modules/2016-todoapp-with-mixins.png[width=960px]


[.dan]
=== Mixins

[source,java]
----
@Mixin
public class ToDoItem_next {
    private final ToDoItem toDoItem;
    public ToDoItem_next(final ToDoItem toDoItem) { ... }

    public ToDoItem $$() { ... }
}
----



[.dan]
=== Domain events

[source,java]
----
public static class CompletedDomainEvent
                    extends ToDoItem.ActionDomainEvent {}
@Action(
    domainEvent = CompletedDomainEvent.class
)
public ToDoItem completed() {
    setComplete(true);
}
----


[.dan]
[%notitle]
=== Domain events

[source,java]
----
@DomainService
public class ItemCompletedSubscriber {
    @Subscribe
    public void on(ToDoItem.CompletedDomainEvent ev) {
        ToDoItem item = ev.getSource();
        switch(ev.getEventPhase()) {
            case HIDE:      // ev.hide();
                break;
            case DISABLE:   // ev.disable(...);
                break;
            case VALIDATE:  // ev.invalidate(...);
                break;
            case EXECUTING: // ...
                break;
            case EXECUTED:  // ...
                break;
        }
    }
}
----




[.dan]
=== Pre-built modules

* Technical modules
** link:http://www.isisaddons.org[www.isisaddons.org]

* Generic (business) sub-domains
** link:http://catalog.incode.org[catalog.incode.org]





[.eoin]
== Enterprise Architecture

In this context EA is the design of the "system of systems" that forms the technology environment for an organisation

Common concerns for an EA group include:

[%step]

* What is the functional scope of each system?
* How do systems interact to support business processes?
* Where is data mastered, owned, copied, changed, accessed?
* How is data stored?
* What technical standardisation is valuable?  What what will the standards be?

How can Isis help or hinder the evolution of an enterprise's technology architecture?

[NOTE.speaker]
====
eoin: let's step further out to the enterprise architecture
====



[.dan]
=== Inferred commands

* Each interaction (action invocation or property edit) can be reified into XML
** published onto an event bus, eg Camel
* can be correlated with audit trail
** ie cause/effect


[.dan]
[%notitle]
=== Inferred commands

[source,java]
----
public static class CompletedDomainEvent
                    extends ToDoItem.ActionDomainEvent {}
@Action(
    domainEvent = CompletedDomainEvent.class,
    publishing = Publishing.ENABLED
)
public ToDoItem completed() {
    setComplete(true);
}
----

[.dan .small]
[%notitle]
=== published xml


[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<ixn:interactionDto xmlns:com="http://isis.apache.org/schema/common"
                    xmlns:cmd="http://isis.apache.org/schema/cmd"
                    xmlns:ixn="http://isis.apache.org/schema/ixn">
  <ixn:transactionId>8236d616-6fde-45d9-9526-cb7a50b4bd88</ixn:transactionId>
  <ixn:execution xsi:type="ixn:actionInvocationDto"
       interactionType="action_invocation"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <ixn:sequence>0</ixn:sequence>
    <ixn:target type="todo.ToDoItem" id="0"/>
    <ixn:memberIdentifier>todoapp.dom.todoitem.ToDoItem#completed()</ixn:memberIdentifier>
    <ixn:parameters/>
    <ixn:returned type="reference" null="false">
      <com:reference type="todo.ToDoItem" id="0"/>
    </ixn:returned>
    <ixn:user>todoapp-admin</ixn:user>
    <ixn:title>todo.ToDoItem:0: completed()</ixn:title>
    <ixn:metrics>
      <ixn:timings>
        <com:startedAt>2016-09-19T20:36:03.414+01:00</com:startedAt>
        <com:completedAt>2016-09-19T20:36:03.418+01:00</com:completedAt>
      </ixn:timings>
      <ixn:objectCounts>
        <ixn:loaded before="3" after="3"/>
        <ixn:dirtied before="0" after="1"/>
      </ixn:objectCounts>
    </ixn:metrics>
  </ixn:execution>
</ixn:interactionDto>
----



[.dan]
[%notitle]
=== Publishing

image::eai/410.PNG[width=960px]

[.dan]
[%notitle]
=== Publishing

image::eai/420.PNG[width=960px]


[.dan]
[%notitle]
=== Publishing

image::eai/430.PNG[width=960px]


[.dan]
[%notitle]
=== Publishing

image::eai/440.PNG[width=960px]


[.dan]
[%notitle]
=== Publishing

image::eai/450.PNG[width=960px]




[.dan]
=== Other examples

* Security
* i18n
* Swagger generation
* Once you have a metamodel in your hand...




[.eoin]
== Concluding

[%step]

* ...
* ...
* ...



[NOTE.speaker]
====
eoin: ie propogating state between systems "for free"
====




[.dan]
== Example Apps

* link:http://github.com/estatio/estatio[github.com/estatio/estatio]
* link:http://github.com/incodehq/contactapp[github.com/incodehq/contactapp]
* link:http://github.com/incodehq/contactapp[github.com/incodehq/colab2-exploration]
* link:http://github.com/isisaddons/isis-app-todoapp[github.com/isisaddons/isis-app-todoapp]



[.dan]
== Learning More

* link:http://isis.apache.org[isis.apache.org]
* link:http://www.isisaddons.org[www.isisaddons.org]
* link:http://catalog.incode.org[catalog.incode.org]

* link:mailto:dan@haywood-associates.co.uk[dan@haywood-associates.co.uk] and *@dkhaywood*
* link:mailto:Eoin.Woods@endava.com[eoin.woods@endava.com] and *@eoinwoodz*

* link:http://isis.apache.org/resources/thesis/Pawson-Naked-Objects-thesis.pdf[Richard Pawson's Naked Objects PhD thesis]
* slide deck at link:http://github.com/danhaywood/jaxlondon2016[github.com/danhaywood/jaxlondon2016]
