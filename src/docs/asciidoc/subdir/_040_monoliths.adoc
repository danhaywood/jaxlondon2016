[data-transition="slide-in fade-out"]
[data-background="#243"]
== How does the framework support monoliths?

* even though microservices are where the current hype is, most applications are (and probably should continue to be) monoliths

* how do you keep your monolith applications modular; how do they not become big balls of mud?



[NOTE.speaker]
--
for Eoin to ask
--



[data-transition="fade"]
=== How does the framework support monoliths?

* The framework provides two very significant features:
** **mixin**s allow business functionality to be moved out of a domain object
** **domain event**s allow modules to veto or react to changes in other modules

* the framework recombines the logic/validation within its metamodel, creating a coherent UI for the end-user


[NOTE.speaker]
--
for Dan to answer
--




[data-transition="slide-in fade-out"]
=== Mixins

* Domain objects consist of actions, properties and collections

* A *mixin* action removes this logic from the domain object and places it into a separate mixin object
** An object's properties and collections can similarly be factored out

* The mixin is bound to the domain object by the (interface) types that the domain object implements

[NOTE.speaker]
--
Demo
--



[data-transition="fade"]
=== Domain events

* A *domain event* is fired whenever the end-user interacts with a member of the domain object
** hide, disable, validate, executing, executed

* The subscriber can either veto the change, or react to it
** somewhat akin to RDBMS referential integrity, but at the domain layer

* Either link:https://github.com/google/guava[guava] or link:http://www.axonframework.org/[AxonFramework] can be used as the event{nbsp}bus implementation


[NOTE.speaker]
--
Demo
--
